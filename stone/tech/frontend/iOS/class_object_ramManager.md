#内存分析，类与对象，栈堆

##类与对象
1、类的本质

	类的本质其实也是一个对象(类对象)

	程序中第一次使用该类的时候被创建，在整个程序中只有一份。
	
	此后每次使用都是这个类对象，它在程序运行时一直存在。
	
	类对象是一种数据结构,存储类的基本信息:类大小,类名称,类的版本，继承层次，以及消息与函数的映射表等
	
	类对象代表类,Class类型,对象方法属于类对象
	
	如果消息的接收者是类名,则类名代表类对象
	
	所有类的实例都由类对象生成,类对象会把实例的isa的值修改成自己的地址,每个实例的isa都指向该实例的类对象
	

2、OC实例对象 类对象 元对象之间关系

	   元类保存了类方法的列表。当一个类方法被调用时,元类会首先查找它本身是否有该类方法的实现,如果没有则该元类会向它的父类查找该方法,直到一直找到继承链的头。

	   元类(metaclass)也是一个对象,那么元类的isa指针又指向哪里呢?为了设计上的完整,所有的元类的isa指针都会指向一个根元类(root metaclass)。
	
	   根元类(root metaclass)本身的isa指针指向自己,这样就行成了一个闭环。上面说􏰀到,一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中,我们几乎不会遇到向元类发消息的情况,那它的isa 指针在实际上很少用到。不过这么设计保证了面向对象的干净,即所有事物都是对象,都有isa指针。
	
	   由于类方法的定义是保存在元类(metaclass)中,而方法调用的规则是,如果该类没有一个方法的实现,则向它的父类继续查找。所以为了保证父类的类方法可以在子类中可以被调用,所以子类的元类会继承父类的元类,换而言之,类对象和元类对象有着同样的继承关系。


3、详细讲解：（GSPerson类）

	1.程序启动后，系统会将所有类加载进内存-即代码区。

	2.当需要用到GSPerson类时，系统会先在堆中创建一个对象，俗称类对象。

    2.1.内部创建一个isa指针指向源类对象

    2.2系统会在类对象中包含该类的所有成员属性、对象方法

    2.3源类对象：

        2.3.1内部创建一个isa指针指向根源类对象－NSObject

        2.3.2系统会在类对象中包含该类对象方法

         2.3.3根源类对象－NSObject

             2.3.3.1内部创建一个isa指针指向自己本身

	3.[[GSPerson alloc] init]系统做了三件事：

    3.1.alloc:

        3.1.1.内部创建一个isa指针指向类对象

        3.1.2.在堆中分配一块存储空间

        3.1.3.初步初始化，将成员变量初始化为零

        3.1.4.返回对象

    3.2.init：对成员变量进行初始化

    3.3.返回对象
    

4、核心图解

元类，对象，实例，根元类举例：

![元类，对象，实例](http://ok2nitkry.bkt.clouddn.com/class_object_ramManager0.png)

实际应用情况举例：

![实际情况举例](http://ok2nitkry.bkt.clouddn.com/class_object_ramManager1.png)

[简书上很好的讲解](http://www.jianshu.com/p/0a1c4879a2e3)